package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

/**
 * TemplateSubsystem
 *
 * Description:
 * This is a basic skeleton of a WPILib SubsystemBase class, meant to serve as a starting
 * point for building robot subsystems such as drivetrain, shooter, intake, etc.
 *
 * Features:
 * - Provides structure for initializing and organizing hardware components.
 * - Includes lifecycle hooks like `periodic()` and `simulationPeriodic()`.
 * - Includes command factory methods for use in triggers and autonomous.
 * - Uses WPILib's fluent-style command composition (runOnce, andThen, startEnd, etc.).
 *
 * Notes:
 * - Add motors, sensors, or other components as fields and initialize them in the constructor.
 * - Use `periodic()` for regular control or sensor updates.
 * - Replace example methods with actual subsystem logic.
 */
public class TemplateSubsystem extends SubsystemBase {

    /**
     * Constructor for TemplateSubsystem.
     * Initialize hardware components and configure subsystem defaults here.
     */
    public TemplateSubsystem() {
        // Example: initialize motors, encoders, sensors, etc.
    }

    /**
     * Called once per scheduler run (every ~20ms).
     * Use this for sensor reads, dashboard updates, or control loops.
     */
    @Override
    public void periodic() {
        // Example: SmartDashboard.putNumber("Sensor", sensor.getValue());
    }

    /**
     * Called only in simulation environments, periodically.
     */
    @Override
    public void simulationPeriodic() {
        // Simulation-specific logic
    }

    /**
     * Example control method to activate a device or motor.
     */
    public void doSomething() {
        // Example: motor.set(0.5);
    }

    /**
     * Example method to stop a device or reset outputs.
     */
    public void stop() {
        // Example: motor.set(0);
    }

    /**
     * Example getter method to check a subsystem status.
     * 
     * @return boolean status
     */
    public boolean getStatus() {
        // Example: return limitSwitch.get();
        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // Command Factory Methods
    // ─────────────────────────────────────────────────────────────

    /**
     * Runs `doSomething()` continuously while the command is active.
     */
    public Command runDoSomethingCommand() {
        return run(this::doSomething);
    }

    /**
     * Runs `doSomething()` once, immediately when scheduled.
     */
    public Command runOnceCommand() {
        return runOnce(this::doSomething);
    }

    /**
     * Runs `doSomething()` when started, and `stop()` when interrupted or ended.
     */
    public Command startEndCommand() {
        return startEnd(this::doSomething, this::stop);
    }

    /**
     * Waits until a condition becomes true (e.g., a sensor activates).
     */
    public Command waitUntilReadyCommand() {
        return waitUntil(this::getStatus);
    }

    /**
     * targetCommand()
     * 
     * Description:
     * Runs a one-time setup in `initialize()` using `runOnce()`,
     * followed by a repeating action using `run()`.
     * 
     * This compact form replaces writing a full Command subclass manually.
     *
     * Example Use:
     * - Setup a target mechanism, then track it while the command is active.
     * 
     * Returns a command like:
     *     initialize() → doSomething()
     *     execute()    → print or adjust repeatedly
     *     end()        → optional (not used here)
     */
    public Command targetCommand() {
        return runOnce(() -> {
            System.out.println("One-time setup");
            doSomething();
        }).andThen(run(() -> {
            System.out.println("Tracking...");
            // Replace with continuous tracking logic
        }));
    }

    /**
     * Same as targetCommand(), but calls `stop()` when ended or interrupted.
     */
    public Command targetCommandWithStop() {
        return runOnce(() -> {
            doSomething(); // One-time setup
        }).andThen(startEnd(
            () -> System.out.println("Tracking in progress..."),
            this::stop
        ));
    }
}
